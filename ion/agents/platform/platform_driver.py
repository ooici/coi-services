#!/usr/bin/env python

"""
@package ion.agents.platform.platform_driver
@file    ion/agents/platform/platform_driver.py
@author  Carlos Rueda
@brief   Base class for platform drivers
"""

__author__ = 'Carlos Rueda'
__license__ = 'Apache 2.0'


from pyon.public import log
import logging

from ion.agents.platform.platform_driver_event import DriverEvent
from ion.agents.platform.exceptions import PlatformDriverException

from ion.agents.instrument.common import BaseEnum
from ion.agents.instrument.instrument_fsm import InstrumentFSM, FSMError
from ion.agents.platform.exceptions import PlatformConnectionException
from ion.agents.platform.util.network_util import NetworkUtil


class PlatformDriverState(BaseEnum):
    """
    Platform driver states
    """
    UNCONFIGURED     = 'PLATFORM_DRIVER_STATE_UNCONFIGURED'
    DISCONNECTED     = 'PLATFORM_DRIVER_STATE_DISCONNECTED'
    CONNECTED        = 'PLATFORM_DRIVER_STATE_CONNECTED'


class PlatformDriverEvent(BaseEnum):
    """
    Base events for driver state machines.
    """
    ENTER            = 'PLATFORM_DRIVER_EVENT_ENTER'
    EXIT             = 'PLATFORM_DRIVER_EVENT_EXIT'

    CONFIGURE        = 'PLATFORM_DRIVER_EVENT_CONFIGURE'
    CONNECT          = 'PLATFORM_DRIVER_EVENT_CONNECT'
    CONNECTION_LOST  = 'PLATFORM_DRIVER_CONNECTION_LOST'
    DISCONNECT       = 'PLATFORM_DRIVER_EVENT_DISCONNECT'

    # Events for the CONNECTED state:
    PING                      = 'PLATFORM_DRIVER_PING'
    GET_METADATA              = 'PLATFORM_DRIVER_GET_METADATA'
    GET_ATTRIBUTE_VALUES      = 'PLATFORM_DRIVER_GET_ATTRIBUTE_VALUES'
    SET_ATTRIBUTE_VALUES      = 'PLATFORM_DRIVER_SET_ATTRIBUTE_VALUES'
    CONNECT_INSTRUMENT        = 'PLATFORM_DRIVER_CONNECT_INSTRUMENT'
    DISCONNECT_INSTRUMENT     = 'PLATFORM_DRIVER_DISCONNECT_INSTRUMENT'
    GET_CONNECTED_INSTRUMENTS = 'PLATFORM_DRIVER_GET_CONNECTED_INSTRUMENTS'
    TURN_ON_PORT              = 'PLATFORM_DRIVER_TURN_ON_PORT'
    TURN_OFF_PORT             = 'PLATFORM_DRIVER_TURN_OFF_PORT'
    GET_CHECKSUM              = 'PLATFORM_DRIVER_GET_CHECKSUM'


class PlatformDriver(object):
    """
    A platform driver handles a particular platform in a platform network.
    """

    def __init__(self, pnode, evt_recv):
        """
        Creates a PlatformDriver instance.

        @param pnode     Root PlatformNode defining the platform network rooted at
                         this platform.
        @param evt_recv  Listener of events generated by this driver
        """
        assert pnode, "pnode must be given"
        assert evt_recv, "evt_recv parameter must be given"

        self._pnode = pnode
        self._send_event = evt_recv

        self._platform_id = self._pnode.platform_id
        if self._pnode.parent:
            self._parent_platform_id = self._pnode.parent.platform_id
        else:
            self._parent_platform_id = None

        self._platform_attributes = \
            dict((a.attr_id, a.defn) for a in self._pnode.attrs.itervalues())

        if log.isEnabledFor(logging.DEBUG):
            log.debug("%r: PlatformDriver constructor called: pnode:\n%s\n"
                      "_platform_attributes=%s",
                      self._platform_id,
                      NetworkUtil._dump_pnode(self._pnode, include_subplatforms=False),
                      self._platform_attributes)

        self._driver_config = None

        # construct FSM and start it with initial state UNCONFIGURED:
        self._construct_fsm()
        self._fsm.start(PlatformDriverState.UNCONFIGURED)

    def _get_platform_attributes(self):
        """
        Gets a dict of the attribute definitions in this platform as given at
        construction time (from pnode parameter).
        """
        return self._platform_attributes

    def _validate_driver_configuration(self, driver_config):
        """
        Called by configure so a subclass can perform any needed additional
        validation of the provided configuration.
        Nothing is done in this base class. Note that basic validation is
        done by PlatformAgent prior to creating/configuring the driver.

        @param driver_config Driver configuration.

        @raise PlatformDriverException Error in driver configuration.
        """

    def configure(self, driver_config):
        """
        Configures this driver. It first calls _validate_driver_configuration.

        @param driver_config Driver configuration.
        """
        if log.isEnabledFor(logging.DEBUG):
            log.debug("%r: configure: %s" % (self._platform_id, str(driver_config)))

        self._validate_driver_configuration(driver_config)
        self._driver_config = driver_config

    def connect(self):
        """
        To be implemented by subclass.
        Establishes communication with the platform device.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def disconnect(self):
        """
        To be implemented by subclass.
        Ends communication with the platform device.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def ping(self):
        """
        To be implemented by subclass.
        Verifies communication with external platform returning "PONG" if
        this verification completes OK.

        @retval "PONG"
        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def get_metadata(self):
        """
        To be implemented by subclass.
        Returns the metadata associated to the platform.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def get_attribute_values(self, attr_names, from_time):
        """
        To be implemented by subclass.
        Returns the values for specific attributes since a given time.

        @param attr_names [attrName, ...] desired attributes
        @param from_time time from which the values are requested.
                         Assummed to be in the format basically described by
                         pyon's get_ion_ts function, "a str representing an
                         integer number, the millis in UNIX epoch."

        @retval {attrName : [(attrValue, timestamp), ...], ...}
                dict indexed by attribute name with list of (value, timestamp)
                pairs. Timestamps in same format as from_time.
        """
        raise NotImplementedError()  #pragma: no cover

    def set_attribute_values(self, attrs):
        """
        To be implemented by subclass.
        Sets values for writable attributes in this platform.

        @param attrs 	[(attrName, attrValue), ...] 	List of attribute values

        @retval {platform_id: {attrName : [(attrValue, timestamp), ...], ...}}
                dict with a single entry for the requested platform ID and value
                as a list of (value,timestamp) pairs for each attribute indicated
                in the input. Returned timestamps indicate the time when the
                value was set. Each timestamp is "a str representing an
                integer number, the millis in UNIX epoch;" this is to be
                aligned with description of pyon's get_ion_ts function.
        """
        raise NotImplementedError()  #pragma: no cover

    def connect_instrument(self, port_id, instrument_id, attributes):
        """
        To be implemented by subclass.
        Connects an instrument to a port in this platform.

        @param port_id      Port ID
        @param instrument_id Instrument ID
        @param attributes   Attribute dictionary

        @retval The resulting configuration for the instrument.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def disconnect_instrument(self, port_id, instrument_id):
        """
        To be implemented by subclass.
        Disconnects an instrument from a port in this platform.

        @param port_id      Port ID
        @param instrument_id Instrument ID

        @retval

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def get_connected_instruments(self, port_id):
        """
        To be implemented by subclass.
        Retrieves the IDs of the instruments connected to a port.

        @param port_id      Port ID

        @retval

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def turn_on_port(self, port_id):
        """
        To be implemented by subclass.
        Turns on a port in this platform.

        @param port_id      Port ID

        @retval The resulting on/off of the port.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def turn_off_port(self, port_id):
        """
        To be implemented by subclass.
        Turns off a port in this platform.

        @param port_id      Port ID

        @retval The resulting on/off of the port.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def destroy(self):
        """
        Stops all activity done by the driver. Nothing done in this class.
        (previously it stopped resource monitoring).
        """

    def _notify_driver_event(self, driver_event):
        """
        Convenience method for subclasses to send a driver event to
        corresponding platform agent.

        @param driver_event a DriverEvent object.
        """
        log.debug("platform driver=%r: notify driver_event=%s",
            self._platform_id, driver_event)

        assert isinstance(driver_event, DriverEvent)

        self._send_event(driver_event)

    def get_checksum(self):
        """
        To be implemented by subclass.
        Returns the checksum for this platform.

        @return SHA1 hash value as string of hexadecimal digits.
        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def get_driver_state(self):
        """
        Returns the current FSM state.
        """
        return self._fsm.get_current_state()

    ##############################################################
    # FSM event handlers.
    ##############################################################

    def _common_state_enter(self, *args, **kwargs):
        """
        Common work upon every state entry.
        Nothing done in this base class.
        @todo determine what should be done, in particular regarding eventual
        notification of the platform driver state transition.
        """
        state = self.get_driver_state()
        if log.isEnabledFor(logging.DEBUG):
            log.debug('%r: driver entering state: %s' % (self._platform_id, state))

        # TODO: publish the platform driver FSM state transition?
        # event_data = {
        #     'state': state
        # }
        # result = self._event_publisher.publish_event(
        #     event_type = ?????,
        #     origin     = ?????,
        #     **event_data)
        # if log.isEnabledFor(logging.DEBUG):
        #     log.debug('%r: PlatformDriver published state change: %s, '
        #               'time: %s result: %s',
        #               self._platform_id, state, get_ion_ts(), str(result))

    def _common_state_exit(self, *args, **kwargs):
        """
        Common work upon every state exit.
        Nothing done in this base class.
        """

    ##############################################################
    # UNCONFIGURED event handlers.
    ##############################################################

    def _handler_unconfigured_configure(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        driver_config = kwargs.get('driver_config', None)
        if driver_config is None:
            raise FSMError('configure: missing driver_config argument')

        try:
            result = self.configure(driver_config)
            next_state = PlatformDriverState.DISCONNECTED
        except PlatformDriverException as e:
            result = None
            next_state = None
            log.error("Error in platform driver configuration", e)

        return next_state, result

    ##############################################################
    # DISCONNECTED event handlers.
    ##############################################################

    def _handler_disconnected_connect(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self.connect()
        next_state = PlatformDriverState.CONNECTED

        return next_state, result

    ##############################################################
    # CONNECTED event handlers.
    ##############################################################

    def _handler_connected_disconnect(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self.disconnect(*args, **kwargs)
        next_state = PlatformDriverState.DISCONNECTED

        return next_state, result

    def _handler_connected_ping(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = None
        try:
            result = self.ping()
            next_state = None
        except PlatformConnectionException as e:
            next_state = PlatformDriverState.DISCONNECTED
            log.error("Ping failed", e)

        return next_state, result

    def _handler_connected_get_metadata(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self.get_metadata()
        next_state = None

        return next_state, result

    def _handler_connected_get_attribute_values(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        attr_names = kwargs.get('attr_names', None)
        if attr_names is None:
            raise FSMError('get_attribute_values: missing attr_names argument')

        from_time = kwargs.get('from_time', None)
        if from_time is None:
            raise FSMError('get_attribute_values: missing from_time argument')

        result = self.get_attribute_values(attr_names, from_time)
        next_state = None

        return next_state, result

    def _handler_connected_set_attribute_values(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        attrs = kwargs.get('attrs', None)
        if attrs is None:
            raise FSMError('set_attribute_values: missing attrs argument')

        result = self.set_attribute_values(attrs)
        next_state = None

        return next_state, result

    def _handler_connected_connect_instrument(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('connect_instrument: missing port_id argument')

        instrument_id = kwargs.get('instrument_id', None)
        if instrument_id is None:
            raise FSMError('connect_instrument: missing instrument_id argument')

        attributes = kwargs.get('attributes', None)
        if attributes is None:
            raise FSMError('connect_instrument: missing attributes argument')

        result = self.connect_instrument(port_id, instrument_id, attributes)
        next_state = None

        return next_state, result

    def _handler_disconnected_connect_instrument(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('disconnect_instrument: missing port_id argument')

        instrument_id = kwargs.get('instrument_id', None)
        if instrument_id is None:
            raise FSMError('disconnect_instrument: missing instrument_id argument')

        result = self.disconnect_instrument(port_id, instrument_id)
        next_state = None

        return next_state, result

    def _handler_connected_get_connected_instruments(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('get_connected_instruments: missing port_id argument')

        result = self.get_connected_instruments(port_id)
        next_state = None

        return next_state, result

    def _handler_connected_turn_on_port(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('turn_on_port: missing port_id argument')

        result = self.turn_on_port(port_id)
        next_state = None

        return next_state, result

    def _handler_connected_turn_off_port(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('turn_off_port: missing port_id argument')

        result = self.turn_off_port(port_id)
        next_state = None

        return next_state, result

    def _handler_connected_get_checksum(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self.get_checksum()
        next_state = None

        return next_state, result

    ##############################################################
    # Platform driver FSM setup
    ##############################################################

    def _construct_fsm(self):
        """
        """
        log.debug("constructing fsm")

        self._fsm = InstrumentFSM(PlatformDriverState,
                                  PlatformDriverEvent,
                                  PlatformDriverEvent.ENTER,
                                  PlatformDriverEvent.EXIT)

        for state in PlatformDriverState.list():
            self._fsm.add_handler(state, PlatformDriverEvent.ENTER, self._common_state_enter)
            self._fsm.add_handler(state, PlatformDriverEvent.EXIT, self._common_state_exit)

        # UNCONFIGURED state event handlers:
        self._fsm.add_handler(PlatformDriverState.UNCONFIGURED, PlatformDriverEvent.CONFIGURE, self._handler_unconfigured_configure)

        # DISCONNECTED state event handlers:
        self._fsm.add_handler(PlatformDriverState.DISCONNECTED, PlatformDriverEvent.CONNECT, self._handler_disconnected_connect)

        # CONNECTED state event handlers:
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.DISCONNECT, self._handler_connected_disconnect)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.CONNECTION_LOST, self._handler_connected_disconnect)

        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.PING, self._handler_connected_ping)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET_METADATA, self._handler_connected_get_metadata)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET_ATTRIBUTE_VALUES, self._handler_connected_get_attribute_values)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.SET_ATTRIBUTE_VALUES, self._handler_connected_set_attribute_values)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.CONNECT_INSTRUMENT, self._handler_connected_connect_instrument)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.DISCONNECT_INSTRUMENT, self._handler_disconnected_connect_instrument)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET_CONNECTED_INSTRUMENTS, self._handler_connected_get_connected_instruments)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.TURN_ON_PORT, self._handler_connected_turn_on_port)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.TURN_OFF_PORT, self._handler_connected_turn_off_port)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET_CHECKSUM, self._handler_connected_get_checksum)

#!/usr/bin/env python

"""
@package ion.agents.platform.platform_driver
@file    ion/agents/platform/platform_driver.py
@author  Carlos Rueda
@brief   Base class for platform drivers
"""

__author__ = 'Carlos Rueda'
__license__ = 'Apache 2.0'


from pyon.public import log
import logging

from ion.agents.platform.platform_driver_event import DriverEvent
from ion.agents.platform.platform_driver_event import StateChangeDriverEvent
from ion.agents.platform.exceptions import PlatformDriverException

from pyon.agent.common import BaseEnum
from pyon.agent.instrument_fsm import ThreadSafeFSM
from pyon.agent.instrument_fsm import FSMError
from ion.agents.platform.exceptions import PlatformConnectionException
from ion.agents.platform.util.network_util import NetworkUtil


class PlatformDriverState(BaseEnum):
    """
    Platform driver states
    """
    UNCONFIGURED     = 'PLATFORM_DRIVER_STATE_UNCONFIGURED'
    DISCONNECTED     = 'PLATFORM_DRIVER_STATE_DISCONNECTED'
    CONNECTED        = 'PLATFORM_DRIVER_STATE_CONNECTED'


class PlatformDriverEvent(BaseEnum):
    """
    Base events for driver state machines.
    """
    ENTER            = 'PLATFORM_DRIVER_EVENT_ENTER'
    EXIT             = 'PLATFORM_DRIVER_EVENT_EXIT'

    CONFIGURE        = 'PLATFORM_DRIVER_EVENT_CONFIGURE'
    CONNECT          = 'PLATFORM_DRIVER_EVENT_CONNECT'
    CONNECTION_LOST  = 'PLATFORM_DRIVER_CONNECTION_LOST'
    DISCONNECT       = 'PLATFORM_DRIVER_EVENT_DISCONNECT'

    # Events for the CONNECTED state:
    PING                      = 'PLATFORM_DRIVER_PING'
    GET_METADATA              = 'PLATFORM_DRIVER_GET_METADATA'
    GET                       = 'PLATFORM_DRIVER_GET'
    SET                       = 'PLATFORM_DRIVER_SET'

    EXECUTE                   = 'PLATFORM_DRIVER_EXECUTE'

    # TODO: align with EXECUTE

    GET_PORTS                 = 'PLATFORM_DRIVER_GET_PORTS'
    CONNECT_INSTRUMENT        = 'PLATFORM_DRIVER_CONNECT_INSTRUMENT'
    DISCONNECT_INSTRUMENT     = 'PLATFORM_DRIVER_DISCONNECT_INSTRUMENT'
    GET_CONNECTED_INSTRUMENTS = 'PLATFORM_DRIVER_GET_CONNECTED_INSTRUMENTS'
    TURN_ON_PORT              = 'PLATFORM_DRIVER_TURN_ON_PORT'
    TURN_OFF_PORT             = 'PLATFORM_DRIVER_TURN_OFF_PORT'
    GET_CHECKSUM              = 'PLATFORM_DRIVER_GET_CHECKSUM'


class PlatformDriverCapability(BaseEnum):
    GET_PORTS                 = PlatformDriverEvent.GET_PORTS
    CONNECT_INSTRUMENT        = PlatformDriverEvent.CONNECT_INSTRUMENT
    DISCONNECT_INSTRUMENT     = PlatformDriverEvent.DISCONNECT_INSTRUMENT
    GET_CONNECTED_INSTRUMENTS = PlatformDriverEvent.GET_CONNECTED_INSTRUMENTS
    TURN_ON_PORT              = PlatformDriverEvent.TURN_ON_PORT
    TURN_OFF_PORT             = PlatformDriverEvent.TURN_OFF_PORT
    GET_CHECKSUM              = PlatformDriverEvent.GET_CHECKSUM


class PlatformDriver(object):
    """
    A platform driver handles a particular platform in a platform network.
    """

    def __init__(self, pnode, event_callback):
        """
        Creates a PlatformDriver instance.

        @param pnode           Root PlatformNode defining the platform network
                               rooted at this platform.
        @param event_callback  Listener of events generated by this driver
        """
        assert pnode, "pnode must be given"
        assert event_callback, "event_callback parameter must be given"

        self._pnode = pnode
        self._send_event = event_callback

        self._platform_id = self._pnode.platform_id
        if self._pnode.parent:
            self._parent_platform_id = self._pnode.parent.platform_id
        else:
            self._parent_platform_id = None

        self._platform_attributes = \
            dict((a.attr_id, a.defn) for a in self._pnode.attrs.itervalues())

        if log.isEnabledFor(logging.DEBUG):
            log.debug("%r: PlatformDriver constructor called: pnode:\n%s\n"
                      "_platform_attributes=%s",
                      self._platform_id,
                      NetworkUtil._dump_pnode(self._pnode, include_subplatforms=False),
                      self._platform_attributes)

        self._driver_config = None

        # The parameter dictionary.
        self._param_dict = {}

        # construct FSM and start it with initial state UNCONFIGURED:
        self._construct_fsm()
        self._fsm.start(PlatformDriverState.UNCONFIGURED)

    def get_resource_capabilities(self, current_state=True):
        """
        """
        res_cmds = self._fsm.get_events(current_state)
        res_cmds = self._filter_capabilities(res_cmds)
        res_params = self._param_dict.keys()

        return [res_cmds, res_params]

    def _filter_capabilities(self, events):
        """
        """
        events_out = [x for x in events if PlatformDriverCapability.has(x)]
        return events_out

    def get_resource_state(self, *args, **kwargs):
        """
        Return the current state of the driver.
        @retval str current driver state.
        """
        return self._fsm.get_current_state()

    def get_resource(self, *args, **kwargs):
        """
        """
        return self._fsm.on_event(PlatformDriverEvent.GET, *args, **kwargs)

    def set_resource(self, *args, **kwargs):
        """
        """
        return self._fsm.on_event(PlatformDriverEvent.SET, *args, **kwargs)

    def execute_resource(self, resource_cmd, *args, **kwargs):
        """
        Platform agent calls this directly to trigger the execution of a
        resource command. The actual action occurs in _execute.
        """
        return self._fsm.on_event(PlatformDriverEvent.EXECUTE, resource_cmd, *args, **kwargs)

    def _get_platform_attributes(self):
        """
        Gets a dict of the attribute definitions in this platform as given at
        construction time (from pnode parameter).
        """
        return self._platform_attributes

    def _validate_driver_configuration(self, driver_config):
        """
        Called by configure so a subclass can perform any needed additional
        validation of the provided configuration.
        Nothing is done in this base class. Note that basic validation is
        done by PlatformAgent prior to creating/configuring the driver.

        @param driver_config Driver configuration.

        @raise PlatformDriverException Error in driver configuration.
        """

    def configure(self, driver_config):
        """
        Configures this driver. It first calls _validate_driver_configuration.

        @param driver_config Driver configuration.
        """
        if log.isEnabledFor(logging.DEBUG):
            log.debug("%r: configure: %s" % (self._platform_id, str(driver_config)))

        self._validate_driver_configuration(driver_config)
        self._driver_config = driver_config

    def connect(self):
        """
        To be implemented by subclass.
        Establishes communication with the platform device.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def disconnect(self):
        """
        To be implemented by subclass.
        Ends communication with the platform device.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def ping(self):
        """
        To be implemented by subclass.
        Verifies communication with external platform returning "PONG" if
        this verification completes OK.

        @retval "PONG"
        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def get_metadata(self):
        """
        To be implemented by subclass.
        Returns the metadata associated to the platform.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def get_attribute_values(self, attrs):
        """
        To be implemented by subclass.
        Returns the values for specific attributes since a given time for
        each attribute.

        @param attrs     [(attrName, from_time), ...] desired attributes.
                         from_time Assummed to be in the format basically described by
                         pyon's get_ion_ts function, "a str representing an
                         integer number, the millis in UNIX epoch."

        @retval {attrName : [(attrValue, timestamp), ...], ...}
                dict indexed by attribute name with list of (value, timestamp)
                pairs. Timestamps in same format as from_time.
        """
        raise NotImplementedError()  #pragma: no cover

    def set_attribute_values(self, attrs):
        """
        To be implemented by subclass.
        Sets values for writable attributes in this platform.

        @param attrs 	[(attrName, attrValue), ...] 	List of attribute values

        @retval {attrName : [(attrValue, timestamp), ...], ...}
                dict with a list of (value,timestamp) pairs for each attribute
                indicated in the input. Returned timestamps indicate the time when the
                value was set. Each timestamp is "a str representing an
                integer number, the millis in UNIX epoch" to
                align with description of pyon's get_ion_ts function.

        """
        #
        # TODO Any needed alignment with the instrument case?
        #
        raise NotImplementedError()  #pragma: no cover

    def _execute(self, cmd, *args, **kwargs):
        """
        Executes the given command.
        Subclasses can override to execute particular commands or delegate to
        this base implementation to handle common commands.

        @param cmd   command

        @return
        """

        if cmd == PlatformDriverEvent.GET_CHECKSUM:
            result = self.get_checksum()

        elif cmd == PlatformDriverEvent.GET_PORTS:
            result = self._get_ports()

        elif cmd == PlatformDriverEvent.TURN_ON_PORT:
            result = self.turn_on_port(*args, **kwargs)

        elif cmd == PlatformDriverEvent.TURN_OFF_PORT:
            result = self.turn_off_port(*args, **kwargs)

        elif cmd == PlatformDriverEvent.CONNECT_INSTRUMENT:
            result = self.connect_instrument(*args, **kwargs)

        elif cmd == PlatformDriverEvent.DISCONNECT_INSTRUMENT:
            result = self.disconnect_instrument(*args, **kwargs)

        elif cmd == PlatformDriverEvent.GET_CONNECTED_INSTRUMENTS:
            result = self.get_connected_instruments(*args, **kwargs)

        elif cmd == PlatformDriverEvent.GET_METADATA:
            result = self.get_metadata()

        else:
            # TODO do actual execution
            result = "!! TODO !!: result of _execute: cmd=%s args=%s kwargs=%s" % (
                     cmd, str(args), str(kwargs))

        return result

    def _get_ports(self):
        ports = {}
        for port_id, port in self._pnode.ports.iteritems():
            ports[port_id] = {'network': port.network}
        log.debug("%r: _get_ports: %s", self._platform_id, ports)
        return ports

    def connect_instrument(self, port_id, instrument_id, attributes):
        """
        To be implemented by subclass.
        Connects an instrument to a port in this platform.

        @param port_id      Port ID
        @param instrument_id Instrument ID
        @param attributes   Attribute dictionary

        @retval The resulting configuration for the instrument.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def disconnect_instrument(self, port_id, instrument_id):
        """
        To be implemented by subclass.
        Disconnects an instrument from a port in this platform.

        @param port_id      Port ID
        @param instrument_id Instrument ID

        @retval

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def get_connected_instruments(self, port_id):
        """
        To be implemented by subclass.
        Retrieves the IDs of the instruments connected to a port.

        @param port_id      Port ID

        @retval

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def turn_on_port(self, port_id):
        """
        To be implemented by subclass.
        Turns on a port in this platform.

        @param port_id      Port ID

        @retval The resulting on/off of the port.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def turn_off_port(self, port_id):
        """
        To be implemented by subclass.
        Turns off a port in this platform.

        @param port_id      Port ID

        @retval The resulting on/off of the port.

        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def destroy(self):
        """
        Stops all activity done by the driver. Nothing done in this class.
        (previously it stopped resource monitoring).
        """

    def _notify_driver_event(self, driver_event):
        """
        Convenience method for subclasses to send a driver event to
        corresponding platform agent.

        @param driver_event a DriverEvent object.
        """
        log.debug("platform driver=%r: notify driver_event=%s",
            self._platform_id, driver_event)

        assert isinstance(driver_event, DriverEvent)

        self._send_event(driver_event)

    def get_checksum(self):
        """
        To be implemented by subclass.
        Returns the checksum for this platform.

        @return SHA1 hash value as string of hexadecimal digits.
        @raise PlatformConnectionException
        """
        raise NotImplementedError()  #pragma: no cover

    def get_driver_state(self):
        """
        Returns the current FSM state.
        """
        return self._fsm.get_current_state()

    ##############################################################
    # FSM event handlers.
    ##############################################################

    def _common_state_enter(self, *args, **kwargs):
        """
        Common work upon every state entry.
        """
        state = self.get_driver_state()
        log.debug('%r: driver entering state: %s', self._platform_id, state)

        self._notify_driver_event(StateChangeDriverEvent(state))

    def _common_state_exit(self, *args, **kwargs):
        """
        Common work upon every state exit.
        Nothing done in this base class.
        """

    ##############################################################
    # UNCONFIGURED event handlers.
    ##############################################################

    def _handler_unconfigured_configure(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        driver_config = kwargs.get('driver_config', None)
        if driver_config is None:
            raise FSMError('configure: missing driver_config argument')

        try:
            result = self.configure(driver_config)
            next_state = PlatformDriverState.DISCONNECTED
        except PlatformDriverException as e:
            result = None
            next_state = None
            log.error("Error in platform driver configuration", e)

        return next_state, result

    ##############################################################
    # DISCONNECTED event handlers.
    ##############################################################

    def _handler_disconnected_connect(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self.connect()
        next_state = PlatformDriverState.CONNECTED

        return next_state, result

    ##############################################################
    # CONNECTED event handlers.
    ##############################################################

    def _handler_connected_disconnect(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self.disconnect(*args, **kwargs)
        next_state = PlatformDriverState.DISCONNECTED

        return next_state, result

    def _handler_connected_ping(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = None
        try:
            result = self.ping()
            next_state = None
        except PlatformConnectionException as e:
            next_state = PlatformDriverState.DISCONNECTED
            log.error("Ping failed", e)

        return next_state, result

    def _handler_connected_get_metadata(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self.get_metadata()
        next_state = None

        return next_state, result

    def _handler_connected_get(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        attrs = kwargs.get('attrs', None)
        if attrs is None:
            raise FSMError('get_attribute_values: missing attrs argument')

        result = self.get_attribute_values(attrs)
        next_state = None

        return next_state, result

    def _handler_connected_set(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        attrs = kwargs.get('attrs', None)
        if attrs is None:
            raise FSMError('set_attribute_values: missing attrs argument')

        result = self.set_attribute_values(attrs)
        next_state = None

        return next_state, result

    def _handler_connected_execute(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        if len(args) == 0:
            raise FSMError('execute_resource: missing resource_cmd argument')

        result = self._execute(*args, **kwargs)
        next_state = None

        return next_state, result

    def _handler_connected_get_ports(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self._get_ports()
        next_state = None

        return next_state, result

    def _handler_connected_connect_instrument(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('connect_instrument: missing port_id argument')

        instrument_id = kwargs.get('instrument_id', None)
        if instrument_id is None:
            raise FSMError('connect_instrument: missing instrument_id argument')

        attributes = kwargs.get('attributes', None)
        if attributes is None:
            raise FSMError('connect_instrument: missing attributes argument')

        result = self.connect_instrument(port_id, instrument_id, attributes)
        next_state = None

        return next_state, result

    def _handler_disconnected_connect_instrument(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('disconnect_instrument: missing port_id argument')

        instrument_id = kwargs.get('instrument_id', None)
        if instrument_id is None:
            raise FSMError('disconnect_instrument: missing instrument_id argument')

        result = self.disconnect_instrument(port_id, instrument_id)
        next_state = None

        return next_state, result

    def _handler_connected_get_connected_instruments(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('get_connected_instruments: missing port_id argument')

        result = self.get_connected_instruments(port_id)
        next_state = None

        return next_state, result

    def _handler_connected_turn_on_port(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('turn_on_port: missing port_id argument')

        result = self.turn_on_port(port_id)
        next_state = None

        return next_state, result

    def _handler_connected_turn_off_port(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        port_id = kwargs.get('port_id', None)
        if port_id is None:
            raise FSMError('turn_off_port: missing port_id argument')

        result = self.turn_off_port(port_id)
        next_state = None

        return next_state, result

    def _handler_connected_get_checksum(self, *args, **kwargs):
        """
        """
        if log.isEnabledFor(logging.TRACE):  # pragma: no cover
            log.trace("%r/%s args=%s kwargs=%s" % (
                      self._platform_id, self.get_driver_state(),
                      str(args), str(kwargs)))

        result = self.get_checksum()
        next_state = None

        return next_state, result

    ##############################################################
    # Platform driver FSM setup
    ##############################################################

    def _construct_fsm(self):
        """
        """
        log.debug("constructing fsm")

        self._fsm = ThreadSafeFSM(PlatformDriverState,
                                  PlatformDriverEvent,
                                  PlatformDriverEvent.ENTER,
                                  PlatformDriverEvent.EXIT)

        for state in PlatformDriverState.list():
            self._fsm.add_handler(state, PlatformDriverEvent.ENTER, self._common_state_enter)
            self._fsm.add_handler(state, PlatformDriverEvent.EXIT, self._common_state_exit)

        # UNCONFIGURED state event handlers:
        self._fsm.add_handler(PlatformDriverState.UNCONFIGURED, PlatformDriverEvent.CONFIGURE, self._handler_unconfigured_configure)

        # DISCONNECTED state event handlers:
        self._fsm.add_handler(PlatformDriverState.DISCONNECTED, PlatformDriverEvent.CONNECT, self._handler_disconnected_connect)

        # CONNECTED state event handlers:
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.DISCONNECT, self._handler_connected_disconnect)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.CONNECTION_LOST, self._handler_connected_disconnect)

        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.PING, self._handler_connected_ping)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET_METADATA, self._handler_connected_get_metadata)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET, self._handler_connected_get)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.SET, self._handler_connected_set)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.EXECUTE, self._handler_connected_execute)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET_PORTS, self._handler_connected_get_ports)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.CONNECT_INSTRUMENT, self._handler_connected_connect_instrument)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.DISCONNECT_INSTRUMENT, self._handler_disconnected_connect_instrument)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET_CONNECTED_INSTRUMENTS, self._handler_connected_get_connected_instruments)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.TURN_ON_PORT, self._handler_connected_turn_on_port)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.TURN_OFF_PORT, self._handler_connected_turn_off_port)
        self._fsm.add_handler(PlatformDriverState.CONNECTED, PlatformDriverEvent.GET_CHECKSUM, self._handler_connected_get_checksum)

#!/usr/bin/env python

"""
DatasetAgent: generalized implementation of dataset agent:
- generalized ion interface following the same pattern as instrument agent.
- pluggable behavior to load specialized driver code.
- hands-off interrupt/resume state mechanism: memento generated by poller only has to make sense to that poller

classes defined:
- DatasetAgent
    - abstract base class
    - implements two-state model (streaming or idle)
    - acts as agent, driver client, and driver; simplifies control flow

interrupt/resume state:
- on each callback, the poller provides a memento it can use to keep its position after resume
- after successful parsing, the memento is persisted as part of the agent state
- upon restart, the agent reads the memento and passes to the driver
"""

__author__ = 'Christopher Mueller, Jonathan Newbrough, Bill French'


import os, sys

from pprint import PrettyPrinter

from ooi.logging import log
from ooi.poller import DirectoryPoller
from ooi.reflection import EggCache

from pyon.agent.agent import ResourceAgentEvent
from pyon.agent.agent import ResourceAgentState
from pyon.core.exception import InstStateError
from pyon.public import OT
from pyon.core.bootstrap import IonObject
from pyon.util.containers import get_safe
from pyon.ion.stream import StandaloneStreamPublisher

from ion.agents.instrument.exceptions import InstrumentStateException
from ion.agents.instrument.instrument_agent import InstrumentAgent
from ion.core.includes.mi import DriverEvent
from ion.services.dm.utility.granule.record_dictionary import RecordDictionaryTool

from coverage_model import ParameterDictionary

# TODO: make unique for multiple processes on same VM
EGG_CACHE_DIR='/tmp/eggs%d' % os.getpid()
EGG_CACHE=EggCache(EGG_CACHE_DIR)
DSA_STATE_KEY = 'dsa_state'

class DataSetAgent(InstrumentAgent):
    """
    this dataset agent has two states: autosampling and idle
    based on InstrumentAgent but override methods to simplify flow control
    generalized ion interface, specialization provided by the driver class.
    """
    ORIGIN_TYPE = "Dataset"

    def __init__(self, *args, **kwargs):
        super(DataSetAgent,self).__init__(*args, **kwargs)

        log.debug("Agent: __init__")

    ####
    ##    Response Handlers
    ####
    def _handler_active_unknown_go_inactive(self, *args, **kwargs):
        return (ResourceAgentState.INACTIVE, None)

    def _handler_inactive_go_active(self, *args, **kwargs):
        return (ResourceAgentState.IDLE, None)


    ####
    ##    Helpers
    ####
    def _create_driver_plugin(self):
        try:
            # Ensure the egg cache directory exists. ooi.reflections will fail
            # somewhat silently when this directory doesn't exists.
            if not os.path.isdir(EGG_CACHE_DIR):
                os.makedirs(EGG_CACHE_DIR)

            log.debug("getting plugin config")
            uri = get_safe(self._dvr_config, 'dvr_egg')
            module_name = self._dvr_config['dvr_mod']
            class_name = self._dvr_config['dvr_cls']
            config = self._dvr_config['startup_config']
        except:
            log.error('error in configuration', exc_info=True)
            raise

        egg_name = None
        egg_repo = None
        memento = self._get_state(DSA_STATE_KEY)


        log.warn("Get driver object: %s, %s, %s, %s", class_name, module_name, egg_name, egg_repo)
        if uri:
            egg_name = uri.split('/')[-1] if uri.startswith('http') else uri
            egg_repo = uri[0:len(uri)-len(egg_name)-1] if uri.startswith('http') else None

        log.info("instantiate driver plugin %s.%s", module_name, class_name)
        params = [config, memento, self.publish_callback, self.persist_state_callback, self.exception_callback]
        return EGG_CACHE.get_object(class_name, module_name, egg_name, egg_repo, params)


    def _validate_driver_config(self):
        """
        Verify the agent configuration contains a driver config.  called by uninitialize_initialize handler
        in the IA class
        """
        log.debug("Driver Config: %s", self._dvr_config)
        out = True

        for key in ('startup_config', 'dvr_mod', 'dvr_cls'):
            if key not in self._dvr_config:
                log.error('missing key: %s', key)
                out = False

        for key in ('stream_config', ):
            if key not in self.CFG:
                log.error('missing key: %s', key)
                out = False

        if get_safe(self._dvr_config, 'max_records', 100) < 1:
            log.error('max_records=%d, must be at least 1 or unset (default 100)', self.max_records)
            out = False

        return out

    def _start_driver(self, dvr_config):
        log.warn("DRIVER: _start_driver: %s", dvr_config)
        self._dvr_client = self._create_driver_plugin()

        if self._dvr_client == None:
            log.error("Failed to instantiate driver plugin!")
            raise InstrumentStateException('failed to start driver')

        log.warn("driver client created")

        self._asp.reset_connection()

    def _stop_driver(self, force=True):
        log.warn("DRIVER: _stop_driver")
        self._dvr_client = None

    ####
    ##    Callbacks
    ####
    def persist_state_callback(self, driver_state):
        log.debug("Saving driver state: %r", driver_state)
        self._set_state(DSA_STATE_KEY, driver_state)

    def publish_callback(self, particle):
        for p in particle:
            try:
                log.info("Particle received: %s", p.generate())
                self._async_driver_event_sample(p.generate(), None)
            except:
                log.error("Error logging particle", exc_info=True)

    def exception_callback(self, exception):
        log.error('error in driver', exc_info=True)


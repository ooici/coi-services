#!/usr/bin/env python

"""
@file coi-services/ion/idk/comm_config.py
@author Bill French
@brief Comm Configuration object used to gather and store connection information for the logger.

Usage:

#
# Create a CommConfig object.  Use the factory method to get the correct object type.
# NOTE: We need a metadata object when we construct the CommConfig object (for the driver name)
#
comm_config = get_config_from_type(metadata, 'ethernet'):

#
# Get config from the console (prompts for type)
#
comm_config = comm_config.get_from_console(metadata)

#
# List all know CommConfig types
#
valid_types = CommConfig.valid_type_list()

"""

__author__ = 'Bill French'
__license__ = 'Apache 2.0'

import sys
import os

import yaml

from ion.idk import prompt
from ion.idk.metadata import Metadata


class CommConfig(object):
    """
    Object to collect and store logger configuration information
    """

    ###
    #   Configurations
    ###
    def idk_dir(self):
        """
        @brief get directory to store configuration files
        @retval directory for idk configuration files.
        """
        return os.environ['HOME'] + "/.idk"

    def config_filename(self):
        """
        @brief get filename for comm config file
        @retval filename to comm config yaml
        """
        return self.metadata.name + "_comm.yml"

    def config_path(self):
        """
        @brief return the full path of the configuration file
        @retval path to config file
        """
        return self.idk_dir() + "/" + self.config_filename()


    ###
    #   Private Methods
    ###
    def __init__(self, metadata):
        """
        @brief Constructor, attempt to read from a config file if we have specified a driver name in the metadata
        @param metadata IDK Metadata object
        """
        self.metadata = metadata
        if( self.metadata.name ):
            self.read_from_file()

    def __getitem__(self, *args):
        return args;
        
    def _init_from_yaml(self, yamlInput):
        """
        @brief initialize the object from yaml data.  This method should be sub classed
        @param yamlInput yaml data structure
        """
        if( yamlInput ):
            self.config_type = yamlInput['comm'].get('method')

    def _config_dictionary(self):
        """
        @brief get a dictionary of configuration parameters.  This method should be sub classed to extend config
        @retval dictionary containing all config parameters.
        """
        return { 'method': self.method() }


    ###
    #   Public Methods
    ###
    def display_config(self):
        """
        @brief Pretty print object configuration to stdout.  This method should be sub classed.
        """
        print( "Type: " + self.method() )

    def serialize(self):
        """
        @brief Get yaml dump of object data
        @retval yaml string of object data
        """
        return yaml.dump( {'comm': self._config_dictionary()
        }, default_flow_style=False)

    def dict(self):
        """
        @brief Return a dict for the comm config
        @retval dict of all comm config data
        """
        return self._config_dictionary()
        
    def store_to_file(self):
        """
        @brief Store object config data to a config file.
        """
        outputFile = self.config_path()

        if not os.path.exists(self.idk_dir()):
            os.makedirs(self.idk_dir())

        ofile = open( outputFile, 'w' )

        ofile.write( self.serialize() )
        ofile.close()

    def read_from_file(self,infile = None):
        """
        @brief Read config file and initialize this object
        @param infile filename to read configuration from.  Default is the filename generated by the object.
        """
        if( infile ):
            inputFile = infile
        else:
            inputFile = self.config_path()

        try:
            infile = open( inputFile )

            input = yaml.load( infile )

            if( input ):
                self._init_from_yaml( input )

            infile.close()
        except IOError:
            """
            Silently be ok with not being able to read the file. 
            """

    def get_from_console(self):
        """
        @brief Read comm config from the console.  This should be overloaded in a sub class.
        """
        if( self.confirm_config() ):
            self.store_to_file()
        else:
            return self.get_from_console()

    def confirm_config(self):
        """
        @brief Is the data entered on the console valid?  This should be overloaded in the sub class to do something useful.
        """
        return True


    ###
    #   Static Methods
    ###
    @staticmethod
    def method():
        """
        @brief Defines the "type" of object.  This must be overloaded in the sub class.
        @retval type of comm configuration object.
        """
        return False

    @staticmethod
    def get_config_from_console(metadata, default_type = None):
        """
        @brief Factory method.  Prompt and read the config type from the console
        @param metadata IDK Metadata object used when constructing the CommConfig object.
        @retval A CommConfig object for the type entered on the console
        """
        print( "\nDriver Comm Configuration" )

        # Currently there is only one type so let's just default to that
        #type = prompt.text( 'Type [' + CommConfig.valid_type_string() + ']', default_type )
        type='ethernet'
        print "Type: ethernet"

        config = CommConfig.get_config_from_type(metadata, type)

        if( config ):
            return config
        else:
            return CommConfig.get_config_from_console(metadata, default_type)

    @staticmethod
    def get_config_from_type(metadata, type):
        """
        @brief Factory method.  Get a CommConfig object for the type passed in
        @param metadata IDK Metadata object used when constructing the CommConfig object.
        @param type Type of CommConfig object to create
        @retval A CommConfig object for the type entered on the console
        """
        valid_types = CommConfig.valid_type_list()
        if( valid_types.count( type ) ):
            config = CommConfigEthernet(metadata)
            return config
        else:
            raise Exception( "Invalid type." )

    @staticmethod
    def get_config_from_file(metadata, config_file = None):
        """
        @brief Factory method.  Get a CommConfig object for the type stored in a driver comm_config file
        @param metadata IDK Metadata object used when constructing the CommConfig object.
        @param config_file read comm config from this file instead of the default comm config file.
        @retval A CommConfig object for the type specified in the comm config file.
        """
        config = CommConfig(metadata)

        if(config.config_type):
            return CommConfig.get_config_from_type(metadata,config.config_type)
        else:
            raise Exception("Boom")
            return None

    @staticmethod
    def valid_type_list():
        """
        @brief List all know types of CommConfig objects
        @retval list of all know CommConfig objects
        """
        result = []
        for config in _CONFIG_OBJECTS:
            result.append(config.method())
        return result

    @staticmethod
    def valid_type_string():
        """
        @brief Get a pretty print list of valid CommConfig object types
        @retval comma delimited string of valid CommConfig object types
        """
        return ", ".join(CommConfig.valid_type_list())


class CommConfigEthernet(CommConfig):
    """
    Ethernet CommConfig object.  Defines data store for ethernet based loggers connections
    """

    @staticmethod
    def method(): return 'ethernet'

    def __init__(self, metadata):
        self.device_addr = None
        self.device_port = None
        self.server_addr = None
        self.server_port = None

        CommConfig.__init__(self, metadata)

    def _init_from_yaml(self, yamlInput):
        CommConfig._init_from_yaml(self, yamlInput)

        if( yamlInput ):
            self.device_addr = yamlInput['comm'].get('device_address')
            self.device_port = yamlInput['comm'].get('device_port')
            self.server_addr = yamlInput['comm'].get('server_address')
            self.server_port = yamlInput['comm'].get('server_port')

    def get_from_console(self):
        self.device_addr = prompt.text( 'Device Address', self.device_addr )
        self.device_port = prompt.text( 'Device Port', self.device_port )
        self.server_addr = prompt.text( 'Server Address', self.server_addr )
        self.server_port = prompt.text( 'Server Port', self.server_port )
        CommConfig.get_from_console(self)

    def display_config(self):
        CommConfig.display_config(self)
        print( "Device Address: " + self.device_addr )
        print( "Device Port: " + self.device_port )
        print( "Server Address: " + self.server_addr )
        print( "Server Port: " + self.server_port )

    def _config_dictionary(self):
        config = CommConfig._config_dictionary(self)
        config['device_addr'] = self.device_addr
        config['device_port'] = int(self.device_port)
        config['server_addr'] = self.server_addr
        config['server_port'] = int(self.server_port)

        return config


# List of all known CommConfig objects
_CONFIG_OBJECTS = [ CommConfigEthernet ]


if __name__ == '__main__':
    metadata = Metadata( name = 'sbe37', author = 'foo', email = 'goo', notes = 'foosd' );

    #comm_config = CommConfig.get_config_from_console(metadata)
    comm_config = CommConfig.get_config_from_type(metadata, 'ethernet')
    comm_config.read_from_file()
    comm_config.get_from_console()

